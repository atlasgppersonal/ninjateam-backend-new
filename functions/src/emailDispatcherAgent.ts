import * as functions from "firebase-functions";
import {db} from "./utils/firebase"; // Import the centralized db instance
import * as admin from "firebase-admin"; // Keep admin for FieldValue.serverTimestamp()
import {toZonedTime} from "date-fns-tz";
import {getDay} from "date-fns";
import type { Client } from '@microsoft/microsoft-graph-client';

// Placeholder for Personalization Agent interaction
async function callPersonalizationAgent(contextObject: any): Promise<{ finalSubject: string; finalBodyHtml: string }> {
  // This is a placeholder function. In a real scenario, this would involve:
  // 1. Making an HTTP call to the Personalization Agent's endpoint.
  // 2. Passing the contextObject (leadDetails, template, intel) as payload.
  // 3. Receiving the fully formed subject and body from the Personalization Agent.

  functions.logger.info("Calling Personalization Agent (placeholder)...", contextObject);

  // Simulate a response from the Personalization Agent
  const simulatedSubject = `Personalized Subject for ${contextObject.leadDetails?.name || "Lead"}`;
  const simulatedBody = `
        <p>Hi ${contextObject.leadDetails?.name || "there"},</p>
        <p>This is a highly personalized email generated by the Personalization Agent.</p>
        <p>Based on our intel, we noticed: ${JSON.stringify(contextObject.intel)}</p>
        <p>Original template subject: ${contextObject.template?.baseSubject}</p>
        <p>Original template body: ${contextObject.template?.baseBodyHtml}</p>
        <p>We are excited to help your business, ${contextObject.leadDetails?.businessName || "your business"}, grow!</p>
        ${contextObject.leadDetails?.phone ? `<p>Phone: ${contextObject.leadDetails.phone}</p>` : ''}
        <p>Best regards,</p>
        <p>Your AI Platform Team</p>
    `;

  return {
    finalSubject: simulatedSubject,
    finalBodyHtml: simulatedBody,
  };
}

// Helper to get system configuration
async function getSystemConfig() {
  const configDoc = await db.collection("systemConfig").doc("live").get();
  if (!configDoc.exists) {
    throw new Error("System configuration not found!");
  }
  return configDoc.data() as any;
}

// Helper to get Microsoft Graph Client
async function getGraphClient(refreshToken: string, clientId: string, tenantId: string): Promise<any> {
  const {Client} = await import('@microsoft/microsoft-graph-client');
  // This is a simplified token refresh logic. In production, you'd use a proper OAuth library.
  const tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
  const scope = "https://graph.microsoft.com/Mail.Send https://graph.microsoft.com/User.Read offline_access";

  const response = await fetch(tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({
      client_id: clientId,
      scope: scope,
      refresh_token: refreshToken,
      grant_type: "refresh_token",
    }).toString(),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to refresh access token: ${response.status} - ${errorText}`);
  }

    interface TokenData {
      access_token: string;
      refresh_token?: string;
      // Add other properties if needed, e.g., expires_in, token_type
    }
    const tokenData = await response.json() as TokenData;
    const accessToken = tokenData.access_token;
    const newRefreshToken = tokenData.refresh_token; // Get new refresh token if provided

    // Update refresh token in Firestore if it changed
    if (newRefreshToken && newRefreshToken !== refreshToken) {
      await db.collection("systemConfig").doc("live").update({microsoftRefreshToken: newRefreshToken});
      functions.logger.info("Microsoft refresh token updated in Firestore.");
    }

    const client = Client.init({
      authProvider: (done) => {
        done(null, accessToken);
      },
    });

    return client;
}

// Helper to send email
async function sendEmail(graphClient: Client, fromAddress: string, toAddress: string, subject: string, bodyHtml: string, attachments: any[] = []) {
  const email = {
    message: {
      subject: subject,
      body: {
        contentType: "HTML",
        content: bodyHtml,
      },
      toRecipients: [
        {
          emailAddress: {
            address: toAddress,
          },
        },
      ],
      attachments: attachments.map((att) => ({
        "@odata.type": "#microsoft.graph.fileAttachment",
        "name": att.name,
        "contentBytes": att.contentBytes,
        "contentId": att.contentId,
        "isInline": att.isInline,
      })),
    },
    saveToSentItems: true,
  };

  try {
    await graphClient.api("/me/sendMail").post(email);
    functions.logger.info(`Email sent successfully to ${toAddress}`);
    return true;
  } catch (error) {
    functions.logger.error(`Failed to send email to ${toAddress}:`, error);
    return false;
  }
}

// Helper for human-like timing
async function applyHumanLikeDelay(config: any) {
  const intervalSettings = config.consumerSettings.timing_settings.interval_between_emails_seconds;
  const duration = Math.floor(Math.random() * (intervalSettings.max - intervalSettings.min + 1)) + intervalSettings.min;
  functions.logger.info(`Applying human-like delay for ${duration} seconds.`);
  await new Promise((resolve) => setTimeout(resolve, duration * 1000));
}

// Helper for timezone and working hours check
function isWithinWorkingHours(config: any, timezone: string): boolean {
  const now = new Date();
  const zonedDate = toZonedTime(now, timezone);

  const dayOfWeek = getDay(zonedDate); // 0 for Sunday, 1 for Monday, etc.
  const hour = zonedDate.getHours();
  const minute = zonedDate.getMinutes();

  const workHours = config.consumerSettings.timing_settings.working_hours;
  if (!workHours.enabled) {
    return true;
  }

  const [startHour, startMinute] = workHours.start_time_military.split(":").map(Number);
  const [endHour, endMinute] = workHours.end_time_military.split(":").map(Number);

  // Map date-fns getDay() to your work_days array (e.g., "Sunday", "Monday")
  const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const currentDayName = dayNames[dayOfWeek];

  const isWorkday = workHours.work_days.includes(currentDayName);
  const isAfterStartTime = (hour > startHour) || (hour === startHour && minute >= startMinute);
  const isBeforeEndTime = (hour < endHour) || (hour === endHour && minute <= endMinute);

  return isWorkday && isAfterStartTime && isBeforeEndTime;
}

// Main email-agent function
export async function processEmailQueue(event: any) {
  const snapshot = event.data;
  if (!snapshot) {
    functions.logger.error("No data associated with the event.");
    return;
  }
  const emailQueueEntry = snapshot.data();
  const contactId = emailQueueEntry.contactId;
  const templateId = emailQueueEntry.templateId;
  const leadTimezone = emailQueueEntry.timezone;
  const queueDocId = snapshot.id;

  functions.logger.info(`Processing email for contactId: ${contactId}, templateId: ${templateId}`);

  try {
    const systemConfig = await getSystemConfig();

    // 1. Check working hours for the lead's timezone
    if (!isWithinWorkingHours(systemConfig, leadTimezone)) {
      functions.logger.info(`Skipping email for ${contactId} - outside working hours in ${leadTimezone}. Will retry later.`);
      // Optionally, update status to 'pending_retry' or similar and use a scheduled function to re-queue
      return;
    }

    // 2. Data Aggregation
    const contactDoc = await db.collection("contacts").doc(contactId).get();
    if (!contactDoc.exists) {
      functions.logger.warn(`Contact ${contactId} not found for email queue entry ${queueDocId}.`);
      await snapshot.ref.update({status: "error_no_contact", sentAt: admin.firestore.FieldValue.serverTimestamp()});
      return;
    }
    const leadDetails = contactDoc.data();

    const templateDoc = await db.collection("templates").doc(templateId).get();
    if (!templateDoc.exists) {
      functions.logger.warn(`Template ${templateId} not found for email queue entry ${queueDocId}.`);
      await snapshot.ref.update({status: "error_no_template", sentAt: admin.firestore.FieldValue.serverTimestamp()});
      return;
    }
    const template = templateDoc.data();

    // Aggregate intel from other agents (placeholder for now)
    const intel = {
      // Example: Fetch data from subcollections if they exist
      // gbpProfile: (await db.collection('contacts').doc(contactId).collection('google_business_profile').doc('profile').get()).data(),
      // seoAnalysis: (await db.collection('contacts').doc(contactId).collection('seo_analysis').doc('keywords').get()).data(),
      // competitorAnalysis: (await db.collection('contacts').doc(contactId).collection('competitor_analysis').doc('matrix').get()).data(),
    };

    const contextObject = {
      leadDetails,
      template,
      intel,
    };

    // 3. Interaction with Personalization Agent
    const {finalSubject, finalBodyHtml} = await callPersonalizationAgent(contextObject);

    // 4. Prepare attachments (base64 encode if necessary)
    const attachments = [];
    const emailAttachmentsConfig = systemConfig.consumerSettings.email_attachments || {};
    for (const [contentId, filePath] of Object.entries(emailAttachmentsConfig)) {
      // In a real Cloud Function, you'd fetch these from Cloud Storage or embed directly if small.
      // For now, we'll simulate base64 content.
      functions.logger.warn(`Attachment ${contentId} from ${filePath} is a placeholder. Real content needs to be fetched.`);
      attachments.push({
        name: contentId, // Use contentId as name for simplicity in placeholder
        contentBytes: Buffer.from(`Simulated content for ${contentId}`).toString("base64"),
        contentId: contentId,
        isInline: true,
      });
    }

    // 5. Get Microsoft Graph Client and send email
    const graphClient = await getGraphClient(
      systemConfig.microsoftRefreshToken,
      systemConfig.emailClientId,
      systemConfig.emailTenantId
    );

    const fromAddress = (await graphClient.api("/me").get()).mail; // Get sender's email from Graph API

    const emailSent = await sendEmail(
      graphClient,
      fromAddress,
            leadDetails!.email, // Add non-null assertion
            finalSubject,
            finalBodyHtml,
            attachments
    );

    if (emailSent) {
      await snapshot.ref.update({status: "sent", sentAt: admin.firestore.FieldValue.serverTimestamp()});
      await db.collection("contacts").doc(contactId).update({status: "emailed", lastUpdated: admin.firestore.FieldValue.serverTimestamp()});
      // Apply human-like delay after successful send
      await applyHumanLikeDelay(systemConfig);
    } else {
      await snapshot.ref.update({status: "error_api_failure", sentAt: admin.firestore.FieldValue.serverTimestamp()});
    }
  } catch (error) {
    functions.logger.error(`Error processing email for ${contactId}:`, error);
    await snapshot.ref.update({status: "error_unexpected", sentAt: admin.firestore.FieldValue.serverTimestamp()});
  }
}
