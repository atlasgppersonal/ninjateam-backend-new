import * as fs from 'fs';
import { parse } from 'csv-parse';
import { stringify } from 'csv-stringify';

const INPUT_FILE = 'c:/Users/GIO PLUGLIESE/Downloads/ai_studio_code (2).txt';
const OUTPUT_FILE = 'functions/lib/scripts/processed_sms_data.csv';
const BASE_URL = 'https://ninjateam.ai/lp/craigslist?h=';
const MAX_CHARS_PER_COLUMN = 200; // Target around 200 characters per column

function generateRandomHash(length: number = 4): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function splitMessage(message: string): string[] {
  const parts: string[] = [];
  let currentPart = '';
  let lastSentenceEnd = -1;

  for (let i = 0; i < message.length; i++) {
    currentPart += message[i];

    // Check for sentence end
    if (['.', '?', '!'].includes(message[i]) && (i + 1 === message.length || message[i+1] === ' ' || message[i+1] === '\n')) {
      lastSentenceEnd = i;
    }

    if (currentPart.length >= MAX_CHARS_PER_COLUMN) {
      if (lastSentenceEnd !== -1 && lastSentenceEnd > i - MAX_CHARS_PER_COLUMN) {
        // Split at the last sentence end within the current part's range
        parts.push(message.substring(0, lastSentenceEnd + 1).trim());
        message = message.substring(lastSentenceEnd + 1).trim();
        currentPart = '';
        lastSentenceEnd = -1;
        i = -1; // Reset i for the new message string
      } else {
        // No natural sentence break, split at MAX_CHARS_PER_COLUMN
        parts.push(currentPart.trim());
        message = message.substring(currentPart.length).trim();
        currentPart = '';
        lastSentenceEnd = -1;
        i = -1; // Reset i for the new message string
      }
    }
  }

  if (currentPart.length > 0) {
    parts.push(currentPart.trim());
  }

  // Ensure there are always 3 parts, even if empty
  while (parts.length < 3) {
    parts.push('');
  }

  return parts.slice(0, 3); // Return only the first 3 parts
}


async function processCsv() {
  const records: any[] = [];
  const parser = fs.createReadStream(INPUT_FILE).pipe(parse({ columns: true, skip_empty_lines: true }));

  for await (const record of parser) {
    let smsText = record.sms_text;

    if (smsText.includes('[Link]')) {
      const hash = generateRandomHash();
      const personalizedLink = `${BASE_URL}${hash}`;
      smsText = smsText.replace(/\[Link\]/g, personalizedLink);
    }

    const messageParts = splitMessage(smsText);

    records.push({
      phone_number: record.phone_number,
      sms_text_part1: messageParts[0],
      sms_text_part2: messageParts[1],
      sms_text_part3: messageParts[2],
    });
  }

  stringify(records, { header: true }, (err: any, output: string | undefined) => {
    if (err) {
      console.error('Error stringifying CSV:', err);
      return;
    }
    if (output) {
      fs.writeFileSync(OUTPUT_FILE, output);
      console.log(`Processed data written to ${OUTPUT_FILE}`);
    } else {
      console.error('No output generated by csv-stringify.');
    }
  });
}

processCsv().catch(console.error);
